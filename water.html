<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>颜色排序解题器</title>
    <style>
        :root {
            --bubble-height: 35px; /* 每个颜色块的高度，修改此值即可调整所有颜色块高度和试管总高度 */
        }
        body {
            font-family: Arial, sans-serif;
            max-width: 100%;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            overflow: hidden;
            height: 100vh;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px auto;
            max-width: 95%;
            width: 100%;
            box-sizing: border-box;
            height: calc(100vh - 40px);
            overflow: hidden;
            display: flex;
            flex-direction: row;
            gap: 20px;
        }
        .left-sidebar {
            width: 200px;
            flex-shrink: 0;
            overflow-y: auto;
            padding-right: 10px;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden;
        }
        .right-sidebar {
            width: 250px;
            flex-shrink: 0;
            overflow-y: auto;
            padding-left: 10px;
        }
        .board {
            margin: 20px 0 0 0;
            overflow-y: auto;
            overflow-x: visible;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            min-height: 0;
            padding-bottom: 10px;
        }
        .tube-row {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 15px;
            margin: 1px auto;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            flex-wrap: wrap;
        }
        .tube {
            display: flex;
            flex-direction: column;
            width: 60px;
            border: 2px solid #333;
            border-radius: 0 0 10px 10px;
            background: #f0f0f0;
            padding: 5px;
            position: relative;
            transition: transform 0.2s;
        }
        .tube-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tube-content {
            display: flex;
            flex-direction: column-reverse;
            height: calc(var(--bubble-height) * 4); /* 自动计算：4个颜色块的高度 */
            gap: 0; /* 移除缝隙 */
        }
        .bubble {
            width: 50px;
            height: var(--bubble-height); /* 使用CSS变量，便于统一调整 */
            border-radius: 4px; /* 轻微圆角 */
            margin: 0 auto;
            border: 1px solid #999;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: rgba(0,0,0,0.5);
        }
        h1 {
            margin: 0 0 20px 0;
            font-size: 24px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        .lang-switch {
            font-size: 14px;
            padding: 5px 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #f0f0f0;
            cursor: pointer;
            user-select: none;
        }
        .lang-switch:hover {
            background: #e0e0e0;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
            flex-shrink: 0;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        .solve-btn {
            background: #2196F3;
        }
        .solve-btn:hover {
            background: #1976D2;
        }
        .reset-btn {
            background: #f44336;
        }
        .reset-btn:hover {
            background: #d32f2f;
        }
        .add-tube-btn {
            background: #FF9800;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            margin-left: 10px;
            height: 30px;
        }
        .add-tube-btn:hover {
            background: #F57C00;
        }
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 0 0 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            width: 100%;
            box-sizing: border-box;
        }
        .color-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #333;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            position: relative;
        }
        .color-btn .color-name {
            font-size: 12px;
            font-weight: bold;
        }
        .color-btn .color-count {
            font-size: 10px;
            margin-top: 2px;
            opacity: 0.9;
        }
        .color-btn:hover {
            transform: scale(1.1);
        }
        .selected-color {
            border: 3px solid #000 !important;
            box-shadow: 0 0 8px rgba(0,0,0,0.3);
        }
        .selected-bubble {
            border: 3px solid #2196F3 !important;
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.5);
        }
        .solution {
            margin-top: 20px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 5px;
            display: none;
        }
        .move {
            margin: 5px 0;
            padding: 5px;
            background: #d4edda;
            border-radius: 3px;
        }
        .progress {
            margin: 10px 0;
            display: none;
        }
        .stats {
            margin: 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 5px;
            position: sticky;
            top: 0;
        }
        .row-title {
            font-weight: bold;
            margin-bottom: 10px;
            text-align: left;
            color: #333;
            width: 100%;
            padding-left: 5px;
        }
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #fff;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            max-width: 400px;
            font-size: 14px;
            color: #333;
            display: none;
            animation: toastSlideIn 0.3s ease-out;
        }
        .toast.show {
            display: block;
        }
        .toast-content {
            line-height: 1.5;
            margin: 0;
        }
        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-sidebar">
            <div class="color-palette" id="colorPalette">
                <!-- 颜色调色板将在这里生成 -->
            </div>
        </div>
        
        <div class="main-content">
            <h1>
                <span id="titleText">Color Sort Solver</span>
                <span class="lang-switch" id="langSwitch" onclick="toggleLanguage()">ZH/EN</span>
            </h1>
            
            <div class="controls">
                <button id="btnRandom" onclick="generateRandomPuzzle()">Random</button>
                <button id="btnSolve" onclick="solvePuzzle()">Solve</button>
                <button id="btnReset" onclick="resetBoard()">Reset</button>
                <button id="btnClear" onclick="clearAll()">Clear All</button>
                <button id="btnExport" onclick="exportPuzzle()">Export</button>
                <button id="prevStepBtn" onclick="prevStep()" style="display:none;">← Prev</button>
                <button id="nextStepBtn" onclick="nextStep()" style="display:none;">Next →</button>
            </div>
            
            <div class="board" id="board">
                <!-- 游戏板将在这里生成 -->
            </div>
            
            <div class="progress" id="progress">
                <p id="progressText">Calculating solution...</p>
                <p id="progressState">States tried: <span id="stateCount">0</span></p>
            </div>
            
            <div class="solution" id="solution">
                <h3 id="solutionTitle">Solution:</h3>
                <div id="solutionSteps"></div>
            </div>
            
        </div>
        
        <div class="right-sidebar">
            <div class="stats" id="stats" style="display:none;">
                <p id="statsContent">Steps: 0 | Time: 0ms</p>
            </div>
        </div>
    </div>
    
    <!-- 气泡提示 -->
    <div class="toast" id="toast">
        <div class="toast-content" id="toastContent"></div>
    </div>

    <script>
        // 语言配置（默认中文）
        let currentLang = 'zh';
        const translations = {
            en: {
                title: 'Color Sort Solver',
                btnRandom: 'Generate Random',
                btnSolve: 'AutoSolve',
                btnReset: 'Reset',
                btnClear: 'Clear All',
                btnExport: 'Save Current',
                btnPrev: '← Prev',
                btnNext: 'Next →',
                progressText: 'Calculating solution...',
                progressState: 'States tried:',
                solutionTitle: 'Solution:',
                statsSteps: 'Steps:',
                statsTime: 'Time:',
                statsNoSolution: 'No solution found or solution too complex',
                toastMaxTubes: 'Maximum 8 tubes per row!',
                toastMinTubes: 'At least 3 tubes must be kept!',
                toastSelectPosition: 'Please select a tube position first',
                btnAddTube: '+ Add Tube',
                toastValidation: {
                    emptyTubes: 'Puzzle incomplete: Need 2 empty tubes, currently have',
                    incompleteTubes: 'Puzzle incomplete: Except empty tubes, other tubes must be full (4 colors each), currently have',
                    invalidColors: 'Puzzle incomplete: Each color must have exactly 4, incorrect colors:',
                    totalColors: 'Puzzle incomplete: Total color count incorrect, should have',
                    currentlyHave: 'currently have'
                }
            },
            zh: {
                title: '颜色排序解题器',
                btnRandom: '随机生成',
                btnSolve: '求解',
                btnReset: '重置',
                btnClear: '清空所有',
                btnExport: '保存题目',
                btnPrev: '← 上一步',
                btnNext: '下一步 →',
                progressText: '正在计算解决方案...',
                progressState: '已尝试状态:',
                solutionTitle: '解决方案:',
                statsSteps: '解法步数:',
                statsTime: '时间:',
                statsNoSolution: '未找到解决方案或解决方案太复杂',
                toastMaxTubes: '每行最多只能有8个试管！',
                toastMinTubes: '至少需要保留3个试管！',
                toastSelectPosition: '请先选择一个试管位置',
                btnAddTube: '+ 添加试管',
                toastValidation: {
                    emptyTubes: '题目不完整：需要有2个空试管，当前有',
                    incompleteTubes: '题目不完整：除了空试管外，其他试管必须全满（每个试管4个颜色），当前有',
                    invalidColors: '题目不完整：每个颜色必须有且只有4个，以下颜色数量不正确：',
                    totalColors: '题目不完整：总颜色数不正确，应该有',
                    currentlyHave: '当前有'
                }
            }
        };
        
        // 切换语言
        function toggleLanguage() {
            currentLang = currentLang === 'en' ? 'zh' : 'en';
            updateLanguage();
        }
        
        // 更新页面语言
        function updateLanguage() {
            const t = translations[currentLang];
            
            // 更新标题
            document.getElementById('titleText').textContent = t.title;
            
            // 更新按钮
            document.getElementById('btnRandom').textContent = t.btnRandom;
            document.getElementById('btnSolve').textContent = t.btnSolve;
            document.getElementById('btnReset').textContent = t.btnReset;
            document.getElementById('btnClear').textContent = t.btnClear;
            document.getElementById('btnExport').textContent = t.btnExport;
            document.getElementById('prevStepBtn').textContent = t.btnPrev;
            document.getElementById('nextStepBtn').textContent = t.btnNext;
            
            // 更新进度文本
            document.getElementById('progressText').textContent = t.progressText;
            const progressStateEl = document.getElementById('progressState');
            const stateCount = document.getElementById('stateCount').textContent;
            progressStateEl.innerHTML = t.progressState + ' <span id="stateCount">' + stateCount + '</span>';
            
            // 更新解决方案标题
            document.getElementById('solutionTitle').textContent = t.solutionTitle;
            
            
            // 更新统计信息（如果已显示）
            const statsContent = document.getElementById('statsContent');
            if (statsContent && statsContent.textContent.indexOf('解法步数') !== -1 || statsContent.textContent.indexOf('Steps:') !== -1) {
                // 如果显示的是步数和时间，需要重新格式化
                const match = statsContent.textContent.match(/(\d+).*?(\d+)/);
                if (match) {
                    statsContent.textContent = `${t.statsSteps} ${match[1]} | ${t.statsTime} ${match[2]}ms`;
                } else if (statsContent.textContent.indexOf('未找到') !== -1 || statsContent.textContent.indexOf('No solution') !== -1) {
                    statsContent.textContent = t.statsNoSolution;
                }
            }
            
            // 重新渲染board以更新"添加试管"按钮文本
            renderBoard();
        }
        
        // 自定义颜色配置
        const colors = [
            {name: '红', code: '#ea0130'},
            {name: '白色', code: '#cccccc'},
            {name: '深蓝', code: '#014397'},
            {name: '橙', code: '#ff7901'},
            {name: '紫', code: '#5d2a89'},
            {name: '砖红', code: '#b34b2e'},
            {name: '天蓝', code: '#017eca'},
            {name: '米色', code: '#d5a07a'},
            {name: '深绿', code: '#01663e'},
            {name: '黄', code: '#fdcd01'},
            {name: '浅绿', code: '#97ca01'},
            {name: '粉', code: '#f837de'},
            {name: '绿', code: '#08a702'},
            {name: '青', code: '#2ce7d6'},
            {name: '深灰', code: '#555555'}
        ];
        
        let tubes = [];
        let maxDepth = 200; // 限制搜索深度防止内存溢出
        let maxStates = 200000; // 限制最大状态数
        let selectedColorIndex = -1; // 当前选择的颜色索引
        let selectedTubeIndex = -1; // 当前选择的试管索引
        let selectedPosition = -1; // 当前选择的位置
        let rowSizes = [5, 6, 5]; // 记录每行的试管数量，第一行5个，第二行6个，第三行5个
        let toastTimer = null; // 用于存储自动关闭的定时器
        let solutionSteps = []; // 存储解题步骤
        let currentStepIndex = -1; // 当前查看的步骤索引
        let originalTubesState = null; // 保存原始状态
        
        // 显示气泡提示
        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastContent = document.getElementById('toastContent');
            
            // 清除之前的定时器
            if (toastTimer) {
                clearTimeout(toastTimer);
                toastTimer = null;
            }
            
            toastContent.textContent = message;
            toast.classList.add('show');
            
            // 5秒后自动关闭
            toastTimer = setTimeout(() => {
                closeToast();
            }, 5000);
        }
        
        // 关闭气泡提示
        function closeToast() {
            const toast = document.getElementById('toast');
            
            toast.classList.remove('show');
            
            // 清除定时器
            if (toastTimer) {
                clearTimeout(toastTimer);
                toastTimer = null;
            }
        }
        
        function updateStatsDisplay({ steps = 0, time = 0, message = null } = {}) {
            const statsEl = document.getElementById('stats');
            const statsContent = document.getElementById('statsContent');
            const t = translations[currentLang];

            if (!statsEl || !statsContent) {
                return;
            }

            if (message !== null) {
                statsContent.textContent = message;
            } else {
                statsContent.textContent = `${t.statsSteps} ${steps} | ${t.statsTime} ${time}ms`;
            }

            statsEl.style.display = 'block';
        }

        // 颜色名称到索引的映射
        function getColorIndexByName(colorName) {
            const colorMap = {
                '红': 0, '白色': 1, '白': 1, '深蓝': 2, '橙': 3, '紫': 4,
                '砖红': 5, '褐': 5, '天蓝': 6, '米色': 7, '肉': 7,
                '深绿': 8, '黄': 9, '浅绿': 10, '黄绿': 10, // 黄绿映射到浅绿
                '粉': 11, '绿': 12, '青': 13, '浅蓝': 13, // 浅蓝映射到青色
                '深灰': 14, '黑': 14, // 黑色用深灰代替
                '兰': 2, '蓝': 2 // 同深蓝
            };
            return colorMap[colorName] !== undefined ? colorMap[colorName] : 14; // 默认深灰
        }
        
        // 加载默认题目（input_colors1）
        function loadDefaultPuzzle() {
            const inputColors1 = `
深蓝 黄 天蓝 红
白色 青 深绿 黄
米色 深蓝 砖红 天蓝
米色 粉 深蓝 天蓝
米色 粉 绿 白色
浅绿 紫 黄 橙
浅绿 橙 深绿 白色
浅绿 红 砖红 砖红
青 紫 深绿 绿
青 绿 紫 绿
粉 紫 米色 橙
粉 浅绿 白色 红
天蓝 红 深绿 青
黄 橙 深蓝 砖红
`;
            
            // 解析题目
            const lines = inputColors1.trim().split('\n').filter(line => line.trim());
            const requiredTubes = lines.length + 2; // 15个满试管 + 2个空试管 = 17个试管
            
            // 固定3行：第一行5个，第二行6个，第三行5个
            const fixedRowSizes = [5, 6, 5];
            const totalFixedTubes = fixedRowSizes.reduce((sum, size) => sum + size, 0);
            
            // 如果需要的试管数量超过固定行数，将多余的添加到第一行
            if (requiredTubes > totalFixedTubes) {
                fixedRowSizes[0] += (requiredTubes - totalFixedTubes);
            } else if (requiredTubes < totalFixedTubes) {
                // 如果需要的试管数量少于固定行数，从第一行减少
                fixedRowSizes[0] = Math.max(1, fixedRowSizes[0] - (totalFixedTubes - requiredTubes));
            }
            
            // 确保rowSizes总和等于requiredTubes
            const currentTotal = fixedRowSizes.reduce((sum, size) => sum + size, 0);
            if (currentTotal !== requiredTubes) {
                // 如果总和仍然不匹配，调整第一行
                fixedRowSizes[0] += (requiredTubes - currentTotal);
            }
            
            // 设置rowSizes为固定值
            rowSizes = [...fixedRowSizes];
            
            // 初始化试管数组
            tubes = [];
            for (let i = 0; i < requiredTubes; i++) {
                tubes.push([]);
            }
            
            // 清空所有试管
            for (let i = 0; i < tubes.length; i++) {
                tubes[i] = [];
            }
            
            // 填充颜色（题目中左侧颜色在底部，右侧颜色在顶部）
            // 数组索引0是底部，索引3是顶部
            // 所以从左到右（第一个到最后一个）应该从索引0开始填充
            for (let i = 0; i < lines.length; i++) {
                const colorNames = lines[i].trim().split(/\s+/);
                // 从左到右填充，第一个颜色在底部（索引0），最后一个颜色在顶部（索引3）
                for (let j = 0; j < colorNames.length && j < 4; j++) {
                    const colorIndex = getColorIndexByName(colorNames[j]);
                    tubes[i].push(colorIndex);
                }
            }
            
            // 最后2个试管保持空（已经是空的了）
            
            renderBoard();
            renderColorPalette();
            updateColorCounts();
        }
        
        // 初始化游戏
        function initGame() {
            tubes = [];
            // 固定3行：第一行5个，第二行6个，第三行5个
            const fixedRowSizes = [5, 6, 5];
            const totalTubes = fixedRowSizes.reduce((sum, size) => sum + size, 0);
            
            for (let i = 0; i < totalTubes; i++) {
                tubes.push([]); // 所有试管默认为空
            }
            
            // 重置rowSizes为固定值
            rowSizes = [...fixedRowSizes];
            
            renderBoard();
            renderColorPalette();
        }
        
        // 计算每个颜色的数量
        function getColorCounts() {
            const counts = new Array(colors.length).fill(0);
            tubes.forEach(tube => {
                tube.forEach(colorIndex => {
                    if (colorIndex !== undefined && colorIndex >= 0 && colorIndex < colors.length) {
                        counts[colorIndex]++;
                    }
                });
            });
            return counts;
        }
        
        // 更新颜色计数器
        function updateColorCounts() {
            const counts = getColorCounts();
            document.querySelectorAll('.color-btn').forEach((btn) => {
                const originalIndex = parseInt(btn.dataset.index);
                const countEl = btn.querySelector('.color-count');
                if (countEl && !isNaN(originalIndex)) {
                    countEl.textContent = counts[originalIndex];
                }
            });
        }
        
        // 渲染颜色调色板（按颜色数量排序：未满4个的在前，已满4个的在后）
        function renderColorPalette() {
            const paletteEl = document.getElementById('colorPalette');
            paletteEl.innerHTML = '';
            
            const counts = getColorCounts();
            
            // 创建颜色索引数组，并根据数量排序
            const colorIndices = colors.map((_, index) => index);
            colorIndices.sort((a, b) => {
                const countA = counts[a];
                const countB = counts[b];
                const isFullA = countA >= 4;
                const isFullB = countB >= 4;
                
                // 未满4个的排在前面，已满4个的排在后面
                if (isFullA && !isFullB) return 1;
                if (!isFullA && isFullB) return -1;
                
                // 如果都是未满或都是已满，保持原有顺序
                return a - b;
            });
            
            // 按照排序后的顺序渲染颜色按钮
            colorIndices.forEach((originalIndex) => {
                const color = colors[originalIndex];
                const colorBtn = document.createElement('div');
                colorBtn.className = 'color-btn';
                colorBtn.style.backgroundColor = color.code;
                colorBtn.dataset.index = originalIndex; // 保存原始索引
                
                const countEl = document.createElement('div');
                countEl.className = 'color-count';
                countEl.textContent = counts[originalIndex];
                
                colorBtn.appendChild(countEl);
                
                colorBtn.addEventListener('click', () => {
                    selectColor(originalIndex);
                });
                
                paletteEl.appendChild(colorBtn);
            });
        }
        
        // 选择颜色
        function selectColor(colorIndex) {
            if (selectedTubeIndex === -1 || selectedPosition === -1) {
                showToast(translations[currentLang].toastSelectPosition);
                return;
            }
            
            selectedColorIndex = colorIndex;
            
            // 更新UI显示
            document.querySelectorAll('.color-btn').forEach((btn) => {
                const btnIndex = parseInt(btn.dataset.index);
                if (btnIndex === colorIndex) {
                    btn.classList.add('selected-color');
                } else {
                    btn.classList.remove('selected-color');
                }
            });
            
            // 放置颜色（placeColor会处理自动选择下一格）
            placeColor(selectedTubeIndex, selectedPosition);
            
            // 更新颜色计数器
            updateColorCounts();
            
            // 重新排序颜色调色板（在颜色输入后触发）
            renderColorPalette();
            
            // 恢复选中状态（因为重新渲染后选中状态会丢失）
            setTimeout(() => {
                document.querySelectorAll('.color-btn').forEach((btn) => {
                    const btnIndex = parseInt(btn.dataset.index);
                    if (btnIndex === colorIndex) {
                        btn.classList.add('selected-color');
                    }
                });
            }, 0);
        }
        
        // 计算并应用自动缩放
        function applyAutoScale() {
            const boardEl = document.getElementById('board');
            if (!boardEl || boardEl.children.length === 0) return;
            
            // 计算可用视口高度
            const viewportHeight = window.innerHeight;
            
            // 计算固定元素的高度（按钮区、标题等，颜色区在左侧不计算）
            const controls = document.querySelector('.controls');
            const h1 = document.querySelector('h1');
            const mainContent = document.querySelector('.main-content');
            
            let fixedElementsHeight = 0;
            if (controls) fixedElementsHeight += controls.offsetHeight || 50;
            if (h1) fixedElementsHeight += h1.offsetHeight || 30;
            fixedElementsHeight += 60; // 额外的边距和padding
            
            // 使用main-content的高度而不是viewport高度
            const availableHeight = (mainContent ? mainContent.clientHeight : viewportHeight) - fixedElementsHeight;
            
            // 等待DOM完全渲染后计算实际高度
            setTimeout(() => {
                // 获取board的实际高度（包括所有行）
                const totalHeight = boardEl.scrollHeight || boardEl.offsetHeight;
                
                // 如果需要的空间大于可用空间，计算缩放比例
                if (totalHeight > availableHeight && availableHeight > 0) {
                    // 留出一些余量，确保底部内容可见
                    const scale = Math.min(0.95, Math.max(0.25, (availableHeight - 20) / totalHeight));
                    boardEl.style.transform = `scale(${scale})`;
                    boardEl.style.transformOrigin = 'top center';
                    boardEl.style.marginBottom = '0';
                } else {
                    boardEl.style.transform = '';
                    boardEl.style.transformOrigin = '';
                    boardEl.style.marginBottom = '0';
                }
            }, 200);
        }
        
        // 渲染游戏板 - 固定3行布局
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            // 确保rowSizes固定为3行
            while (rowSizes.length < 3) {
                rowSizes.push(0);
            }
            if (rowSizes.length > 3) {
                rowSizes = rowSizes.slice(0, 3);
            }
            
            let tubeIndex = 0;
            
            // 根据rowSizes来渲染每一行（固定3行）
            for (let row = 0; row < 3 && tubeIndex < tubes.length; row++) {
                const rowEl = document.createElement('div');
                rowEl.className = 'tube-row';
                
                // 使用rowSizes来确定当前行有多少个试管
                const currentRowSize = rowSizes[row];
                const endTube = Math.min(tubeIndex + currentRowSize, tubes.length);
                
                for (let i = tubeIndex; i < endTube; i++) {
                    const tubeEl = document.createElement('div');
                    tubeEl.className = 'tube';
                    tubeEl.dataset.index = i;
                    
                    tubeEl.innerHTML = `
                        <div class="tube-header">
                            <span>${i + 1}</span>
                            <button class="delete-btn" onclick="deleteTube(${i})">×</button>
                        </div>
                        <div class="tube-content">
                            ${renderTubeContent(i)}
                        </div>
                    `;
                    
                    rowEl.appendChild(tubeEl);
                }
                
                // 添加增加试管按钮到每行末尾
                const addBtn = document.createElement('button');
                addBtn.className = 'add-tube-btn';
                addBtn.textContent = translations[currentLang].btnAddTube;
                addBtn.onclick = () => addTubeToRow(row);
                rowEl.appendChild(addBtn);
                
                boardEl.appendChild(rowEl);
                
                tubeIndex = endTube;
            }
            
            // 如果还有剩余的试管，说明rowSizes和tubes.length不匹配，将多余的添加到第一行
            if (tubeIndex < tubes.length) {
                // 计算rowSizes的总和
                const totalRowSizes = rowSizes.reduce((sum, size) => sum + size, 0);
                
                // 如果rowSizes总和小于tubes.length，将多余的添加到第一行
                if (totalRowSizes < tubes.length) {
                    const remainingTubes = tubes.length - totalRowSizes;
                    rowSizes[0] = (rowSizes[0] || 0) + remainingTubes;
                    
                    // 重新渲染第一行以包含多余的试管
                    const firstRowEl = boardEl.children[0];
                    if (firstRowEl) {
                        // 移除第一行的所有试管（保留标题和按钮）
                        const firstRowTubes = firstRowEl.querySelectorAll('.tube');
                        firstRowTubes.forEach(tube => tube.remove());
                        
                        // 重新添加第一行的所有试管
                        const firstRowSize = rowSizes[0];
                        for (let i = 0; i < firstRowSize && i < tubes.length; i++) {
                            const tubeEl = document.createElement('div');
                            tubeEl.className = 'tube';
                            tubeEl.dataset.index = i;
                            
                            tubeEl.innerHTML = `
                                <div class="tube-header">
                                    <span>${i + 1}</span>
                                    <button class="delete-btn" onclick="deleteTube(${i})">×</button>
                                </div>
                                <div class="tube-content">
                                    ${renderTubeContent(i)}
                                </div>
                            `;
                            
                            // 插入到按钮之前
                            const addBtn = firstRowEl.querySelector('.add-tube-btn');
                            firstRowEl.insertBefore(tubeEl, addBtn);
                        }
                    }
                }
            }
            
            // 应用自动缩放（使用setTimeout确保DOM已渲染）
            setTimeout(() => {
                applyAutoScale();
            }, 100);
        }
        
        // 渲染试管内容
        function renderTubeContent(tubeIndex) {
            let content = '';
            // 从底部开始渲染，空位显示为浅色
            // position编号：3=最下面，2=第二格，1=第三格，0=最上面
            // 数组索引：0=底部，1=第二格，2=第三格，3=顶部
            // 所以 position = 3 - arrayIndex
            for (let displayPos = 3; displayPos >= 0; displayPos--) {
                // displayPos是显示位置（3=最下面，0=最上面）
                // arrayIndex是数组索引（0=底部，3=顶部）
                const arrayIndex = 3 - displayPos;
                const isSelected = (selectedTubeIndex === tubeIndex && selectedPosition === displayPos);
                const selectedClass = isSelected ? 'selected-bubble' : '';
                
                if (arrayIndex < tubes[tubeIndex].length && tubes[tubeIndex][arrayIndex] !== undefined && tubes[tubeIndex][arrayIndex] !== null) {
                    const colorIndex = tubes[tubeIndex][arrayIndex];
                    if (colorIndex >= 0 && colorIndex < colors.length) {
                        content += `<div class="bubble ${selectedClass}" style="background-color: ${colors[colorIndex].code};" 
                                    data-tube="${tubeIndex}" data-position="${displayPos}" 
                                    onclick="selectBubble(${tubeIndex}, ${displayPos})"></div>`;
                    } else {
                        content += `<div class="bubble ${selectedClass}" style="background-color: #f0f0f0;" 
                                    data-tube="${tubeIndex}" data-position="${displayPos}" 
                                    onclick="selectBubble(${tubeIndex}, ${displayPos})"></div>`;
                    }
                } else {
                    content += `<div class="bubble ${selectedClass}" style="background-color: #f0f0f0;" 
                                data-tube="${tubeIndex}" data-position="${displayPos}" 
                                onclick="selectBubble(${tubeIndex}, ${displayPos})"></div>`;
                }
            }
            return content;
        }
        
        // 选择试管位置
        function selectBubble(tubeIndex, position) {
            // 清除之前的选择
            document.querySelectorAll('.bubble').forEach(bubble => {
                bubble.classList.remove('selected-bubble');
            });
            
            // 设置新的选择
            selectedTubeIndex = tubeIndex;
            selectedPosition = position;
            
            // 重新渲染以显示选中状态
            renderBoard();
        }
        
        // 放置颜色到指定试管位置
        function placeColor(tubeIndex, position) {
            if (selectedColorIndex === -1) {
                return;
            }
            
            // 确保试管数组足够大
            if (!tubes[tubeIndex]) {
                tubes[tubeIndex] = [];
            }
            
            // 位置是从上到下编号的（3,2,1,0），但数组是从下到上存储的（0,1,2,3）
            // position=3是最下面（显示在最下面），对应数组索引0（底部）
            // position=0是最上面（显示在最上面），对应数组索引3（顶部）
            const arrayIndex = 3 - position;
            
            // 如果指定位置已有颜色，替换它
            if (arrayIndex < tubes[tubeIndex].length && tubes[tubeIndex][arrayIndex] !== undefined) {
                tubes[tubeIndex][arrayIndex] = selectedColorIndex;
            } else {
                // 如果位置为空，填充到用户选择的位置
                const currentLength = tubes[tubeIndex].length;
                
                if (arrayIndex === currentLength) {
                    // 如果选择的位置正好是第一个空位（从底部开始），直接添加
                    tubes[tubeIndex].push(selectedColorIndex);
                } else if (arrayIndex > currentLength) {
                    // 如果选择的位置在已有颜色之上，需要填充到指定位置
                    // 创建一个新数组，在指定位置填充颜色，中间用null占位
                    const newArray = [];
                    // 先复制已有的颜色
                    for (let i = 0; i < currentLength; i++) {
                        newArray.push(tubes[tubeIndex][i]);
                    }
                    // 填充null到指定位置之前
                    for (let i = currentLength; i < arrayIndex; i++) {
                        newArray.push(null);
                    }
                    // 在指定位置填充颜色
                    newArray.push(selectedColorIndex);
                    // 更新数组（保留null，渲染时会正确处理）
                    tubes[tubeIndex] = newArray;
                }
            }
            
            renderBoard();
            updateColorCounts();
            
            // 自动选择下一个位置（同一试管的上一格，从下往上）
            // position=3是最下面，position=2是第二格，position=1是第三格，position=0是最上面
            // 如果当前是position=3（最下面），下一个是position=2
            // 如果当前是position=0（最上面），下一个是position=3（下一个试管的最下面）
            let nextPosition = position - 1;
            let nextTubeIndex = tubeIndex;
            
            if (nextPosition < 0) {
                // 当前试管已填满，选择下一个试管的最下面
                nextTubeIndex = tubeIndex + 1;
                nextPosition = 3; // 下一个试管的最下面
                
                // 如果下一个试管不存在，保持当前选择
                if (nextTubeIndex >= tubes.length) {
                    nextTubeIndex = tubeIndex;
                    nextPosition = 0;
                }
            }
            
            // 自动选择下一个位置
            selectedTubeIndex = nextTubeIndex;
            selectedPosition = nextPosition;
            
            // 清除颜色选择
            selectedColorIndex = -1;
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('selected-color');
            });
            
            // 重新渲染以显示新的选中状态
            renderBoard();
        }
        
        // 添加试管到指定行
        function addTubeToRow(rowIndex) {
            // 固定3行，确保rowSizes有3个元素
            while (rowSizes.length < 3) {
                rowSizes.push(0);
            }
            if (rowSizes.length > 3) {
                rowSizes = rowSizes.slice(0, 3);
            }
            
            // 确保rowIndex在有效范围内
            if (rowIndex < 0 || rowIndex >= 3) {
                rowIndex = 0;
            }
            
            // 计算目标行的起始索引
            let startIndex = 0;
            for (let i = 0; i < rowIndex; i++) {
                startIndex += rowSizes[i] || 0;
            }
            
            // 获取目标行的试管数量
            const currentRowSize = rowSizes[rowIndex] || 0;
            
            // 检查目标行是否已达到最大试管数（限制为每行最多8个试管）
            if (currentRowSize < 8) {
                // 在目标行的末尾添加新试管
                const insertIndex = startIndex + currentRowSize;
                tubes.splice(insertIndex, 0, []);
                
                // 更新rowSizes
                rowSizes[rowIndex] = (rowSizes[rowIndex] || 0) + 1;
                
                renderBoard();
                updateColorCounts();
            } else {
                showToast(translations[currentLang].toastMaxTubes);
            }
        }
        
        // 删除指定试管
        function deleteTube(tubeIndex) {
            if (tubes.length > 3) { // 至少保留3个试管
                // 找到试管所在的行
                let currentIndex = 0;
                let rowIndex = 0;
                for (let i = 0; i < rowSizes.length; i++) {
                    if (tubeIndex < currentIndex + rowSizes[i]) {
                        rowIndex = i;
                        break;
                    }
                    currentIndex += rowSizes[i];
                }
                
                tubes.splice(tubeIndex, 1);
                
                // 更新rowSizes
                if (rowIndex < rowSizes.length && rowSizes[rowIndex] > 0) {
                    rowSizes[rowIndex]--;
                }
                
                renderBoard();
                updateColorCounts();
            } else {
                showToast(translations[currentLang].toastMinTubes);
            }
        }
        
        // 随机生成谜题
        function generateRandomPuzzle() {
            // 使用当前的试管数量
            const numTubes = tubes.length || 16;
            
            // 如果当前没有试管，创建默认数量（固定3行：第一行5个，第二行6个，第三行5个）
            if (tubes.length === 0) {
                const fixedRowSizes = [5, 6, 5];
                const totalTubes = fixedRowSizes.reduce((sum, size) => sum + size, 0);
                for (let i = 0; i < totalTubes; i++) {
                    tubes.push([]);
                }
                // 重置rowSizes为固定值
                rowSizes = [...fixedRowSizes];
            }
            
            // 清空所有试管
            for (let i = 0; i < tubes.length; i++) {
                tubes[i] = [];
            }
            
            // 根据验证规则：需要有2个空试管，其他试管全满
            // 所以满试管数量 = numTubes - 2
            const fullTubes = numTubes - 2;
            const totalBubbles = fullTubes * 4; // 每个满试管4个颜色
            const numColors = Math.floor(totalBubbles / 4);
            const colorsUsed = [];
            
            // 创建颜色组（每个颜色4个）
            for (let i = 0; i < numColors; i++) {
                for (let j = 0; j < 4; j++) {
                    colorsUsed.push(i % colors.length); // 循环使用可用颜色
                }
            }
            
            // 随机打乱颜色
            for (let i = colorsUsed.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [colorsUsed[i], colorsUsed[j]] = [colorsUsed[j], colorsUsed[i]];
            }
            
            // 分配颜色到试管（前fullTubes个试管全满，最后2个保持空）
            let colorIndex = 0;
            for (let i = 0; i < fullTubes; i++) {
                for (let j = 0; j < 4; j++) {
                    if (colorIndex < colorsUsed.length) {
                        tubes[i].push(colorsUsed[colorIndex++]);
                    }
                }
            }
            
            // 最后2个试管保持空（已经是空的了，因为上面已经清空）
            
            renderBoard();
            updateColorCounts();
        }
        
        // 清空所有试管
        function clearAll() {
            for (let i = 0; i < tubes.length; i++) {
                tubes[i] = [];
            }
            renderBoard();
            updateColorCounts();
            
            // 重新排序颜色调色板
            renderColorPalette();
            
            // 默认选择第一个试管最下格（位置3）
            selectedTubeIndex = 0;
            selectedPosition = 3;
            selectedColorIndex = -1;
            
            // 清除之前的选中状态
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('selected-color');
            });
            document.querySelectorAll('.bubble').forEach(bubble => {
                bubble.classList.remove('selected-bubble');
            });
            
            // 重新渲染以显示新的选中状态
            renderBoard();
        }
        
        // Cookie操作辅助函数
        function setCookie(name, value, days = 365) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${encodeURIComponent(value)};expires=${expires.toUTCString()};path=/`;
        }
        
        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) {
                    return decodeURIComponent(c.substring(nameEQ.length, c.length));
                }
            }
            return null;
        }
        
        // 导出当前题目（保存到cookie）
        function exportPuzzle() {
            // 保存当前题目数据到cookie
            const puzzleData = {
                tubes: tubes,
                rowSizes: rowSizes
            };
            
            try {
                const dataString = JSON.stringify(puzzleData);
                setCookie('colorSortPuzzle', dataString);
                const t = translations[currentLang];
                showToast(currentLang === 'zh' ? '题目已保存到Cookie！' : 'Puzzle saved to Cookie!');
            } catch (err) {
                console.error('保存失败:', err);
                const t = translations[currentLang];
                showToast(currentLang === 'zh' ? '保存失败，请重试' : 'Save failed, please try again');
            }
        }
        
        // 从cookie加载题目
        function loadPuzzleFromCookie() {
            const cookieData = getCookie('colorSortPuzzle');
            if (!cookieData) {
                return false;
            }
            
            try {
                const puzzleData = JSON.parse(cookieData);
                
                // 验证数据格式
                if (!puzzleData.tubes || !Array.isArray(puzzleData.tubes)) {
                    return false;
                }
                
                // 恢复题目数据
                tubes = puzzleData.tubes.map(tube => Array.isArray(tube) ? [...tube] : []);
                
                // 恢复行大小配置
                if (puzzleData.rowSizes && Array.isArray(puzzleData.rowSizes)) {
                    rowSizes = [...puzzleData.rowSizes];
                } else {
                    // 如果没有rowSizes，使用默认配置
                    const totalTubes = tubes.length;
                    if (totalTubes <= 5) {
                        rowSizes = [totalTubes, 0, 0];
                    } else if (totalTubes <= 11) {
                        rowSizes = [5, totalTubes - 5, 0];
                    } else {
                        rowSizes = [5, 6, totalTubes - 11];
                    }
                }
                
                renderBoard();
                renderColorPalette();
                updateColorCounts();
                return true;
            } catch (err) {
                console.error('加载Cookie数据失败:', err);
                return false;
            }
        }
        
        // 重置游戏
        function resetBoard() {
            initGame();
            updateColorCounts();
            
            // 重新排序颜色调色板
            renderColorPalette();
            
            // 默认选择第一个试管最下格（位置3）
            selectedColorIndex = -1;
            selectedTubeIndex = 0;
            selectedPosition = 3;
            
            // 清除之前的选中状态
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('selected-color');
            });
            document.querySelectorAll('.bubble').forEach(bubble => {
                bubble.classList.remove('selected-bubble');
            });
            
            // 重新渲染以显示新的选中状态
            renderBoard();
        }
        
        // 验证题目是否完整
        function validatePuzzle() {
            // 统计空试管数量
            let emptyTubes = 0;
            let fullTubes = 0;
            let incompleteTubes = 0;
            
            // 统计每个颜色的数量
            const colorCounts = new Array(colors.length).fill(0);
            
            for (let i = 0; i < tubes.length; i++) {
                const tube = tubes[i];
                
                if (tube.length === 0) {
                    emptyTubes++;
                } else if (tube.length === 4) {
                    fullTubes++;
                    // 统计颜色
                    tube.forEach(colorIndex => {
                        if (colorIndex >= 0 && colorIndex < colors.length) {
                            colorCounts[colorIndex]++;
                        }
                    });
                } else {
                    incompleteTubes++;
                    // 统计颜色
                    tube.forEach(colorIndex => {
                        if (colorIndex >= 0 && colorIndex < colors.length) {
                            colorCounts[colorIndex]++;
                        }
                    });
                }
            }
            
            // 检查空试管数量
            const t = translations[currentLang];
            if (emptyTubes !== 2) {
                return {
                    valid: false,
                    message: `${t.toastValidation.emptyTubes} ${emptyTubes} empty tubes`
                };
            }
            
            // 检查是否有未满的试管（除了2个空试管）
            if (incompleteTubes > 0) {
                return {
                    valid: false,
                    message: `${t.toastValidation.incompleteTubes} ${incompleteTubes} incomplete tubes`
                };
            }
            
            // 检查每个颜色的数量（只检查实际使用的颜色）
            const invalidColors = [];
            const usedColors = [];
            for (let i = 0; i < colorCounts.length; i++) {
                if (colorCounts[i] > 0) {
                    usedColors.push(i);
                    if (colorCounts[i] !== 4) {
                        invalidColors.push({
                            name: colors[i].name,
                            count: colorCounts[i]
                        });
                    }
                }
            }
            
            if (invalidColors.length > 0) {
                const colorList = invalidColors.map(c => `${c.name}(${c.count})`).join(', ');
                return {
                    valid: false,
                    message: `${t.toastValidation.invalidColors} ${colorList}`
                };
            }
            
            // 验证总颜色数是否正确（应该有 (tubes.length - 2) * 4 个颜色，因为有2个空试管）
            const totalColors = colorCounts.reduce((sum, count) => sum + count, 0);
            const expectedColors = (tubes.length - 2) * 4;
            if (totalColors !== expectedColors) {
                return {
                    valid: false,
                    message: `${t.toastValidation.totalColors} ${expectedColors} colors, ${t.toastValidation.currentlyHave} ${totalColors} colors`
                };
            }
            
            return { valid: true };
        }
        
        // Container类：表示一个试管
        class Container {
            constructor(idx) {
                this.idx = idx;
                this.elements = [];
                this.max_size = 4;
                this.completed = false;
                this.TColor = null;
                this.historyStates = new Set(); // 记录该试管曾经处于的状态（用于剪枝）
            }
            
            // 获取当前状态的字符串表示
            getStateKey() {
                if (this.is_empty()) {
                    return ''; // 空试管状态不参与检查
                }
                return this.elements.join(',');
            }
            
            // 检查当前状态是否在历史中（空试管状态除外）
            hasSeenCurrentState() {
                if (this.is_empty()) {
                    return false; // 空试管状态不参与检查
                }
                const currentState = this.getStateKey();
                return this.historyStates.has(currentState);
            }
            
            // 将当前状态添加到历史中（空试管状态除外）
            recordCurrentState() {
                if (!this.is_empty()) {
                    const currentState = this.getStateKey();
                    this.historyStates.add(currentState);
                }
            }
            
            // 从历史中移除当前状态（空试管状态除外）
            removeCurrentState() {
                if (!this.is_empty()) {
                    const currentState = this.getStateKey();
                    this.historyStates.delete(currentState);
                }
            }
            
            is_full() {
                return this.elements.length === this.max_size;
            }
            
            is_empty() {
                return this.elements.length === 0;
            }
            
            is_completed() {
                if (this.completed) return true;
                if (this.is_full()) {
                    if (new Set(this.elements).size === 1) {
                        this.completed = true;
                        return true;
                    }
                }
                return false;
            }
            
            top_color() {
                this.TColor = this.elements.length > 0 ? this.elements[this.elements.length - 1] : null;
                return this.TColor;
            }
            
            can_move_to(other) {
                if (this.completed) return false;
                if (this.is_empty()) return false;
                if (other.is_full()) return false;
                // 如果己方只有一种颜色，对方是空容器，则移动非法
                if (new Set(this.elements).size === 1 && other.is_empty()) return false;
                // 可以移动到空容器，或者移动到顶部颜色相同的容器
                if (other.is_empty() || this.TColor === other.TColor) return true;
                return false;
            }
            
            move(other) {
                const moving_element = this.elements.pop();
                other.elements.push(moving_element);
                this.top_color();
                other.top_color();
            }
            
            activate_move(other) {
                let move_count = 0;
                if (this.can_move_to(other)) {
                    while (this.can_move_to(other)) {
                        this.move(other);
                        move_count++;
                    }
                    return move_count;
                }
                return 0;
            }
            
            reverse_move(other, count) {
                for (let i = 0; i < count; i++) {
                    other.move(this);
                }
                this.top_color();
                other.top_color();
            }
        }
        
        // 检查是否胜利
        function isWin(containers) {
            for (let container of containers) {
                container.is_completed();
            }
            const incomplete_count = containers.filter(c => !c.is_empty() && !c.completed).length;
            return incomplete_count === 0;
        }
        
        // 获取状态快照
        function getStateSnapshot(containers) {
            return containers.map(c => [...c.elements]).join('|');
        }
        
        // 从tubes数组创建containers
        function createContainersFromTubes() {
            const containers = [];
            for (let i = 0; i < tubes.length; i++) {
                const container = new Container(i + 1);
                container.elements = [...tubes[i]];
                container.top_color();
                container.is_completed();
                // 记录初始状态到历史中（空试管状态除外）
                container.recordCurrentState();
                containers.push(container);
            }
            return containers;
        }
        
        // 从containers更新tubes数组
        function updateTubesFromContainers(containers) {
            for (let i = 0; i < containers.length; i++) {
                tubes[i] = [...containers[i].elements];
            }
        }
        
        // 深度优先搜索求解（基于Python算法）
        function autoSolve(containers, history, visitedStates, recursionCount = 0, onStepCallback = null) {
            recursionCount++;
            
            // 检查递归深度限制
            if (recursionCount > maxDepth) {
                return false;
            }
            
            // 检查状态数限制
            if (visitedStates.size > maxStates) {
                return false;
            }
            
            // 检查当前状态是否已经访问过
            const currentState = getStateSnapshot(containers);
            if (visitedStates.has(currentState)) {
                return false;
            }
            visitedStates.add(currentState);
            
            // 更新界面显示（每100次递归更新一次，避免界面卡顿）
            if (recursionCount % 100 === 0 && onStepCallback) {
                onStepCallback(containers, recursionCount, visitedStates.size);
            }
            
            if (isWin(containers)) {
                return true;
            }
            
            for (let i = 0; i < containers.length; i++) {
                for (let j = 0; j < containers.length; j++) {
                    if (i === j) continue;
                    
                    const fromContainer = containers[i];
                    const toContainer = containers[j];
                    
                    if (fromContainer.can_move_to(toContainer)) {
                        // 使用activate_move执行移动，并记录移动的颜色数量
                        const moveCount = fromContainer.activate_move(toContainer);
                        
                        if (moveCount > 0) {
                            // 剪枝优化：如果移动后from和to的顶部颜色都是非空且相同，则跳过这次移动
                            // 因为这种情况下可以继续移动，这次移动本身是无效的
                            if (!fromContainer.is_empty() && !toContainer.is_empty() && 
                                fromContainer.TColor !== null && toContainer.TColor !== null &&
                                fromContainer.TColor === toContainer.TColor) {
                                // 回溯，恢复移动前的状态
                                fromContainer.reverse_move(toContainer, moveCount);
                                // 恢复后需要重新初始化所有容器的派生状态
                                for (let c of containers) {
                                    c.top_color();
                                    c.completed = false;
                                    c.is_completed();
                                }
                                continue; // 跳过这次移动
                            }
                            
                            // 记录移动信息
                            const moveKey = `${fromContainer.idx}>${toContainer.idx}(${moveCount})`;
                            
                            // 递归调用
                            if (autoSolve(containers, history + moveKey + ',', visitedStates, recursionCount, onStepCallback)) {
                                // 找到解决方案，将移动记录添加到history
                                solutionSteps.unshift({
                                    from: fromContainer.idx - 1,
                                    to: toContainer.idx - 1,
                                    count: moveCount,
                                    moveKey: moveKey
                                });
                                return true;
                            }
                            
                            // 回溯，使用reverse_move反向移动
                            fromContainer.reverse_move(toContainer, moveCount);
                            // 恢复后需要重新初始化所有容器的派生状态
                            for (let c of containers) {
                                c.top_color();
                                c.completed = false;
                                c.is_completed();
                            }
                        }
                    }
                }
            }
            
            return false;
        }
        
        // 深度优先搜索求解
        function solvePuzzle() {
            // 清除任何选择状态
            selectedColorIndex = -1;
            selectedTubeIndex = -1;
            selectedPosition = -1;
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('selected-color');
            });
            document.querySelectorAll('.bubble').forEach(bubble => {
                bubble.classList.remove('selected-bubble');
            });
            
            // 验证题目是否完整
            const validation = validatePuzzle();
            if (!validation.valid) {
                showToast(validation.message);
                document.getElementById('solution').style.display = 'none';
                document.getElementById('progress').style.display = 'none';
                document.getElementById('stats').style.display = 'none';
                return;
            }
            
            // 保存原始状态
            originalTubesState = JSON.parse(JSON.stringify(tubes));
            solutionSteps = [];
            currentStepIndex = -1;
            
            // 隐藏前进后退按钮
            document.getElementById('prevStepBtn').style.display = 'none';
            document.getElementById('nextStepBtn').style.display = 'none';
            
            document.getElementById('solution').style.display = 'none';
            document.getElementById('progress').style.display = 'block';
            document.getElementById('stateCount').textContent = '0';
            updateStatsDisplay({ steps: 0, time: 0 });
            
            const startTime = Date.now();
            
            // 创建containers
            const containers = createContainersFromTubes();
            
            // 回调函数：更新界面显示
            function onStepCallback(containers, recursionCount, visitedCount) {
                updateTubesFromContainers(containers);
                renderBoard();
                document.getElementById('stateCount').textContent = recursionCount;
                updateStatsDisplay({ steps: solutionSteps.length, time: Date.now() - startTime });
            }
            
            // 开始求解（使用setTimeout避免阻塞UI）
            setTimeout(() => {
                const visitedStates = new Set();
                const found = autoSolve(containers, '', visitedStates, 0, onStepCallback);
                
                if (found) {
                    // 恢复原始状态
                    tubes = JSON.parse(JSON.stringify(originalTubesState));
                    renderBoard();
                    
                    // 显示前进后退按钮
                    document.getElementById('prevStepBtn').style.display = 'inline-block';
                    document.getElementById('nextStepBtn').style.display = 'inline-block';
                    
                    // 重置到初始状态
                    currentStepIndex = -1;
                    
                    // 更新按钮状态
                    document.getElementById('prevStepBtn').disabled = true;
                    document.getElementById('nextStepBtn').disabled = solutionSteps.length === 0;
                    
                    // 显示解法步数和时间
                    updateStatsDisplay({ steps: solutionSteps.length, time: Date.now() - startTime });
                    document.getElementById('progress').style.display = 'none';
                } else {
                    document.getElementById('solution').style.display = 'none';
                    updateStatsDisplay({ message: translations[currentLang].statsNoSolution });
                    document.getElementById('progress').style.display = 'none';
                }
            }, 100);
        }
        
        // 上一步
        function prevStep() {
            if (currentStepIndex < 0) return;
            
            const step = solutionSteps[currentStepIndex];
            // 反向移动
            for (let i = 0; i < step.count; i++) {
                const color = tubes[step.to].pop();
                tubes[step.from].push(color);
            }
            
            currentStepIndex--;
            renderBoard();
            updateColorCounts();
            
            // 更新按钮状态
            document.getElementById('prevStepBtn').disabled = currentStepIndex < 0;
            document.getElementById('nextStepBtn').disabled = false;
        }
        
        // 下一步
        function nextStep() {
            if (currentStepIndex >= solutionSteps.length - 1) return;
            
            currentStepIndex++;
            const step = solutionSteps[currentStepIndex];
            
            // 执行移动
            for (let i = 0; i < step.count; i++) {
                const color = tubes[step.from].pop();
                tubes[step.to].push(color);
            }
            
            renderBoard();
            updateColorCounts();
            
            // 更新按钮状态
            document.getElementById('prevStepBtn').disabled = false;
            document.getElementById('nextStepBtn').disabled = currentStepIndex >= solutionSteps.length - 1;
        }
        
        // 初始化游戏
        window.onload = function() {
            // 初始化语言（默认英语）
            updateLanguage();
            
            // 先尝试从cookie加载题目，如果没有则加载默认题目
            const loadedFromCookie = loadPuzzleFromCookie();
            if (!loadedFromCookie) {
                // 如果没有cookie或加载失败，加载默认题目
                loadDefaultPuzzle();
            }
            
            // 初始化前进后退按钮状态
            document.getElementById('prevStepBtn').disabled = true;
            document.getElementById('nextStepBtn').disabled = true;
            
            // 监听窗口大小变化，自动调整缩放
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    applyAutoScale();
                }, 100);
            });
        };
    </script>
</body>
</html>

